<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../uva-helper-libs/lodash.html">
<link rel="import" href="../uva-helper-libs/moment-timezone.html">
<link rel="import" href="../uvalib-account/uvalib-account-app.html">
<link rel="import" href="../uvalib-account/uvalib-account-user.html">
<link rel="import" href="../uva-models/uva-library.html">
<link rel="import" href="../uvalib-theme/uvalib-theme.html">
<link rel="import" href="uvalib-form.html">
<link rel="import" href="uvalib-form-style.html">
<link rel="import" href="uvalib-field-html-markup.html">
<link rel="import" href="uvalib-field-select.html">
<link rel="import" href="uvalib-field-input.html">
<link rel="import" href="uvalib-field-email-verify.html">
<link rel="import" href="uvalib-field-file.html">
<link rel="import" href="uvalib-field-hidden.html">
<link rel="import" href="uvalib-field-textarea.html">
<link rel="import" href="uvalib-field-checkbox.html">
<link rel="import" href="uvalib-field-checkboxes.html">
<link rel="import" href="uvalib-field-radios.html">
<link rel="import" href="uvalib-field-datetime.html">
<link rel="import" href="uvalib-field-session-datetime.html">
<link rel="import" href="uvalib-field-repeatable-session-datetime.html">
<link rel="import" href="uvalib-field-repeatable-clip-time.html">
<link rel="import" href="uvalib-field-button.html">
<link rel="import" href="../uvalib-sis-input/uvalib-sis-input.html">
<link rel="import" href="../app-storage/app-localstorage/app-localstorage-document.html">

<dom-module id="uvalib-form-builder">
  <template>
    <custom-style>
      <style include="uvalib-theme uvalib-form-style">
      </style>
    </custom-style>

    <app-localstorage-document key="uvalib-header-height" data="{{_headerHeight}}" session-only></app-localstorage-document>
    <uva-library path="web/forms" items="{{formPage}}" filter="{{_formFilter}}"></uva-library>

    <uvalib-account-app></uvalib-account-app>
    <uvalib-account-user id="user" auto="[[_authenticated]]" contact-info="{{userInfo}}"></uvalib-account-user>

    <div class="field-label required-stmt">Fields marked with an asterisk (*) are required.</div>
    <form method="post" hidden$="[[!_visible]]">
      <input type="hidden" name="authenticated" value="[[_authenticated]]" />

      <div class="errors" hidden$="[[!_invalidValues]]" aria-live$="[[_alertLevel]]">
        <div id="submissionProblems">A problem has occurred.
          <div class="errorCount" hidden$="[[_firebaseProblem]]"> Please address the following <span inner-h-t-m-l="[[_errors.length]]"></span> <span inner-h-t-m-l="[[_errorString(_errors.length)]]"></span> and re-submit the form.</div>
        </div>
        <!--  insert error messages here after submit validation -->
        <nav id="errorList" aria-labelledby="submissionProblems" tabindex="0">
          <ul>
            <template is="dom-repeat" items="[[_errors]]">
              <li><a href="#[[item.id]]" on-click="_handleAnchor">[[item.text]]</a></li>
            </template>
          </ul>
        </nav>
      </div>
      <template is="dom-repeat" items="{{_elements}}" as="elem">
        <template is="dom-if" if="[[_isSection(elem)]]">
          <div class="section" hidden$="{{!_showField(elem,_refresh)}}">
            <h2>[[elem.title]]</h2>
              <template is="dom-repeat" items="{{_getSectionFields(elem)}}" as="fs_elem">
                <template is="dom-if" if="[[_isMarkup(fs_elem)]]">
                  <uvalib-field-html-markup id="[[fs_elem.webform_key]]" element="{{fs_elem}}" hidden$="{{!_showField(fs_elem,_refresh)}}"></uvalib-field-html-markup>
                </template>
                <template is="dom-if" if="[[_isField(fs_elem)]]">
                  <template is="dom-if" if="[[_isHidden(fs_elem)]]">
                    <uvalib-field-hidden id="[[fs_elem.webform_key]]" element="{{fs_elem}}" invalid-values="{{_invalidValues}}"></uvalib-field-hidden>
                  </template>
                  <template is="dom-if" if="[[_isSelect(fs_elem)]]">
                    <uvalib-field-select counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}" hidden$="{{!_showField(fs_elem,_refresh)}}"
                      invalid-values="{{_invalidValues}}" required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-select>
                  </template>
                  <template is="dom-if" if="[[_isRadios(fs_elem)]]">
                    <uvalib-field-radios counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}" hidden$="{{!_showField(fs_elem,_refresh)}}"
                      invalid-values="{{_invalidValues}}" required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-radios>
                  </template>
                  <template is="dom-if" if="[[_isInput(fs_elem)]]">
                    <uvalib-field-input counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}" hidden$="{{!_showField(fs_elem,_refresh)}}"
                      invalid-values="{{_invalidValues}}" required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-input>
                  </template>
                  <template is="dom-if" if="[[_isFile(fs_elem)]]">
                    <uvalib-field-file counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}" hidden$="{{!_showField(fs_elem,_refresh)}}"
                      invalid-values="{{_invalidValues}}" required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-file>
                  </template>
                  <template is="dom-if" if="[[_isCheckbox(fs_elem)]]">
                    <uvalib-field-checkbox counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}" hidden$="{{!_showField(fs_elem,_refresh)}}"
                      invalid-values="{{_invalidValues}}" required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-checkbox>
                  </template>
                  <template is="dom-if" if="[[_isCheckboxes(fs_elem)]]">
                    <uvalib-field-checkboxes counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}" hidden$="{{!_showField(fs_elem,_refresh)}}"
                      invalid-values="{{_invalidValues}}" required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-checkboxes>
                  </template>
                  <template is="dom-if" if="[[_isTextarea(fs_elem)]]">
                    <uvalib-field-textarea counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}" hidden$="{{!_showField(fs_elem,_refresh)}}"
                      invalid-values="{{_invalidValues}}" required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-textarea>
                  </template>
                  <template is="dom-if" if="[[_isButton(fs_elem)]]">
                    <uvalib-field-button id="[[fs_elem.webform_key]]" element="{{fs_elem}}" hidden$="{{!_showField(fs_elem,_refresh)}}"></uvalib-field-button>
                  </template>
                  <template is="dom-if" if="[[_isDateTime(fs_elem)]]">
                    <uvalib-field-datetime counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}"
                      number-choice="[[fs_elem.number_choice]]" date-label="[[fs_elem.date_label]]" date-required="[[fs_elem.date_required]]"
                      start-time-label="[[fs_elem.start_time_label]]" hide-start-time="[[fs_elem.hide_start_time]]" start-time-required="[[fs_elem.start_time_required]]"
                      end-time-label="[[fs_elem.end_time_label]]" hide-end-time="[[fs_elem.hide_end_time]]" end-time-required="[[fs_elem.end_time_required]]"
                      minimum-days-out="[[fs_elem.minimum_days_out]]" minute-step="[[fs_elem.minute_step]]"
                      hidden$="[[!_showField(fs_elem,_refresh)]]" invalid-values="{{_invalidValues}}"
                      required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-datetime>
                  </template>
                  <template is="dom-if" if="[[_isSessionDateTimes(fs_elem)]]">
                    <uvalib-field-session-datetime counter="[[_counter]]" id="[[fs_elem.webform_key]]"
                      element="{{fs_elem}}" value="{{fs_elem.value}}" number-choices="[[fs_elem.number_choices]]"
                      num-choices-required="[[fs_elem.num_choices_required]]" include-session-length="[[fs_elem.include_session_length]]"
                      session-label="[[fs_elem.session_label]]" date-required="[[fs_elem.date_required]]"
                      hide-start-time="[[fs_elem.hide_start_time]]" start-time-required="[[fs_elem.start_time_required]]" start-time-label="[[fs_elem.start_time_label]]"
                      hide-end-time="[[fs_elem.hide_end_time]]" end-time-required="[[fs_elem.end_time_required]]" end-time-label="[[fs_elem.end_time_label]]"
                      minimum-days-out="[[fs_elem.minimum_days_out]]" minute-step="[[fs_elem.minute_step]]"
                      hidden$="[[!_showField(fs_elem,_refresh)]]" invalid-values="{{_invalidValues}}"
                      required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-session-datetime>
                  </template>
                  <template is="dom-if" if="[[_isSectionSelect(fs_elem)]]">
                    <uvalib-sis-input counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}" hidden$="{{!_showField(fs_elem,_refresh)}}" course-default-value$="{{fs_elem.course_default_value}}" show-alternate$="{{fs_elem.show_alternate}}" show-enrollment$="{{fs_elem.show_enrollment}}" show-meeting-time$="{{fs_elem.show_meeting_time}}"></uvalib-sis-input>
                  </template>
                  <template is="dom-if" if="[[_isRepeatableSession(fs_elem)]]">
                    <uvalib-field-repeatable-session-datetime counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}"
                      maximum-occurrences="[[fs_elem.maximum_occurrences]]" include-session-length="[[fs_elem.include_session_length]]"
                      number-choices="[[fs_elem.number_choices]]" num-choices-required="[[fs_elem.num_choices_required]]"
                      session-label="[[fs_elem.session_label]]" date-required="[[fs_elem.date_required]]"
                      hide-start-time="[[fs_elem.hide_start_time]]" start-time-required="[[fs_elem.start_time_required]]" start-time-label="[[fs_elem.start_time_label]]"
                      hide-end-time="[[fs_elem.hide_end_time]]" end-time-required="[[fs_elem.end_time_required]]" end-time-label="[[fs_elem.end_time_label]]"
                      minimum-days-out="[[fs_elem.minimum_days_out]]" minute-step="[[fs_elem.minute_step]]"
                      hidden$="[[!_showField(fs_elem,_refresh)]]" invalid-values="{{_invalidValues}}" header-height="[[_headerHeight]]"
                      required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-repeatable-session-datetime>
                  </template>
                  <template is="dom-if" if="[[_isRepeatableMediaClip(fs_elem)]]">
                    <uvalib-field-repeatable-clip-time counter="[[_counter]]" id="[[fs_elem.webform_key]]" element="{{fs_elem}}" value="{{fs_elem.value}}"
                      maximum-occurrences="[[fs_elem.maximum_occurrences]]" clip-label="[[fs_elem.clip_label]]"
                      hidden$="[[!_showField(fs_elem,_refresh)]]" invalid-values="{{_invalidValues}}" header-height="[[_headerHeight]]"
                      required-error="{{fs_elem.required_error}}" syntax-errors="{{fs_elem.syntax_error}}">
                    </uvalib-field-repeatable-clip-time>
                  </template>
                </template>
    </template>
    </div>
    </template>
    <template is="dom-if" if="[[_isMarkup(elem)]]">
          <uvalib-field-html-markup id="[[elem.webform_key]]" element="{{elem}}" hidden$="{{!_showField(elem,_refresh)}}"></uvalib-field-html-markup>
        </template>
        <template is="dom-if" if="[[_isField(elem)]]">
          <template is="dom-if" if="[[_isHidden(elem)]]">
            <uvalib-field-hidden id="[[elem.webform_key]]" element="{{elem}}" invalid-values="{{_invalidValues}}"></uvalib-field-hidden>
          </template>
          <template is="dom-if" if="[[_isSelect(elem)]]">
            <uvalib-field-select counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}" hidden$="{{!_showField(elem,_refresh)}}"
              invalid-values="{{_invalidValues}}" required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-select>
          </template>
          <template is="dom-if" if="[[_isRadios(elem)]]">
            <uvalib-field-radios counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}" hidden$="{{!_showField(elem,_refresh)}}"
              invalid-values="{{_invalidValues}}"required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-radios>
          </template>
          <template is="dom-if" if="[[_isInput(elem)]]">
            <uvalib-field-input counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}" hidden$="{{!_showField(elem,_refresh)}}"
              invalid-values="{{_invalidValues}}" required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-input>
          </template>
          <template is="dom-if" if="[[_isFile(elem)]]">
            <uvalib-field-file counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}" hidden$="{{!_showField(elem,_refresh)}}"
              invalid-values="{{_invalidValues}}" required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-file>
          </template>
          <template is="dom-if" if="[[_isCheckbox(elem)]]">
            <uvalib-field-checkbox counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}" hidden$="{{!_showField(elem,_refresh)}}"
              invalid-values="{{_invalidValues}}" required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-checkbox>
          </template>
          <template is="dom-if" if="[[_isCheckboxes(elem)]]">
            <uvalib-field-checkboxes counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}" hidden$="{{!_showField(elem,_refresh)}}"
              invalid-values="{{_invalidValues}}" required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-checkboxes>
          </template>
          <template is="dom-if" if="[[_isTextarea(elem)]]">
            <uvalib-field-textarea counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}" hidden$="{{!_showField(elem,_refresh)}}"
              invalid-values="{{_invalidValues}}" required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-textarea>
          </template>
          <template is="dom-if" if="[[_isDateTime(elem)]]">
            <uvalib-field-datetime counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}"
              number-choice="[[elem.number_choice]]" date-label="[[elem.date_label]]" date-required="[[elem.date_required]]"
              start-time-label="[[elem.start_time_label]]" hide-start-time="[[elem.hide_start_time]]" start-time-required="[[elem.start_time_required]]"
              end-time-label="[[elem.end_time_label]]" hide-end-time="[[elem.hide_end_time]]" end-time-required="[[elem.end_time_required]]"
              minimum-days-out="[[elem.minimum_days_out]]" minute-step="[[elem.minute_step]]"
              hidden$="[[!_showField(elem,_refresh)]]" invalid-values="{{_invalidValues}}"
              required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-datetime>
          </template>
          <template is="dom-if" if="[[_isSessionDateTimes(elem)]]">
            <uvalib-field-session-datetime counter="[[_counter]]" id="[[elem.webform_key]]"
              element="{{elem}}" value="{{elem.value}}" number-choices="[[elem.number_choices]]"
              num-choices-required="[[elem.num_choices_required]]" include-session-length="[[elem.include_session_length]]"
              session-label="[[elem.session_label]]" date-required="[[elem.date_required]]"
              hide-start-time="[[elem.hide_start_time]]" start-time-required="[[elem.start_time_required]]" start-time-label="[[elem.start_time_label]]"
              hide-end-time="[[elem.hide_end_time]]" end-time-required="[[elem.end_time_required]]" end-time-label="[[elem.end_time_label]]"
              minimum-days-out="[[elem.minimum_days_out]]" minute-step="[[elem.minute_step]]"
              hidden$="[[!_showField(elem,_refresh)]]" invalid-values="{{_invalidValues}}"
              required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-session-datetime>
          </template>
          <template is="dom-if" if="[[_isSectionSelect(elem)]]">
            <uvalib-sis-input counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}" hidden$="{{!_showField(elem,_refresh)}}" course-default-value$="{{elem.course_default_value}}" show-alternate$="{{elem.show_alternate}}" show-enrollment$="{{elem.show_enrollment}}" show-meeting-time$="{{fs_elem.show_meeting_time}}"></uvalib-sis-input>
          </template>
          <template is="dom-if" if="[[_isRepeatableSession(elem)]]">
            <uvalib-field-repeatable-session-datetime counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}"
              maximum-occurrences="[[fs_elem.maximum_occurrences]]" include-session-length="[[elem.include_session_length]]"
              number-choices="[[elem.number_choices]]" num-choices-required="[[elem.num_choices_required]]"
              session-label="[[elem.session_label]]" date-required="[[elem.date_required]]"
              hide-start-time="[[elem.hide_start_time]]" start-time-required="[[elem.start_time_required]]" start-time-label="[[elem.start_time_label]]"
              hide-end-time="[[elem.hide_end_time]]" end-time-required="[[elem.end_time_required]]" end-time-label="[[elem.end_time_label]]"
              minimum-days-out="[[elem.minimum_days_out]]" minute-step="[[elem.minute_step]]"
              hidden$="[[!_showField(elem,_refresh)]]" invalid-values="{{_invalidValues}}" header-height="[[_headerHeight]]"
              required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-repeatable-session-datetime>
          </template>
          <template is="dom-if" if="[[_isRepeatableMediaClip(elem)]]">
            <uvalib-field-repeatable-clip-time counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}"
              maximum-occurrences="[[elem.maximum_occurrences]]" clip-label="[[elem.clip_label]]"
              hidden$="[[!_showField(elem,_refresh)]]" invalid-values="{{_invalidValues}}" header-height="[[_headerHeight]]"
              required-error="{{elem.required_error}}" syntax-errors="{{elem.syntax_error}}">
            </uvalib-field-repeatable-clip-time>
          </template>
          <template is="dom-if" if="[[_isCaptcha(elem)]]">
            <uvalib-field-email-verify counter="[[_counter]]" id="[[elem.webform_key]]" element="{{elem}}" value="{{elem.value}}"></uvalib-field-email-verify>
          </template>
    </template>
    </template>
    <template is="dom-repeat" items="{{_elements}}" as="elem">
      <template is="dom-if" if="[[_isButton(elem)]]">
        <uvalib-field-button id="[[elem.webform_key]]" element="{{elem}}" hidden$="{{!_showField(elem,_refresh)}}"></uvalib-field-button>
        <div id="networkConnection" hidden$="{{_online}}">[[_offlineMessage(_online,_networkConnectionMsg)]]</div>
      </template>
    </template>
    </form>

  </template>

    <script>
        /**
         * `uvalib-form-builder`
         * Component that builds out a web form UI using a form definition via the API.
         *
         * @customElement
         * @polymer
         * @demo demo/index.html
         * @demo demo/purchase-request.html
         * @demo demo/uvalib-field-button.html
         * @demo demo/uvalib-field-checkbox.html
         * @demo demo/uvalib-form-datetime.html
         * @demo demo/uvalib-field-email-verify.html
         * @demo demo/uvalib-field-file.html
         * @demo demo/uvalib-field-input.html
         * @demo demo/uvalib-field-repeatable-session-datetime.html
         * @demo demo/uvalib-field-select.html
         * @demo demo/uvalib-form-session-datetime.html
         * @demo demo/uvalib-field-textarea.html
         */
        class UvalibFormBuilder extends UvalibForm(Polymer.Element) {
            static get is() {
                return 'uvalib-form-builder';
            }
            static get properties() {
                return Object.assign(super.properties, {
                    /**
                     * Used to indicate which workflow the server should use when processing the request submitted.
                     */
                    formId: {
                        type: String
                    },
                    /**
                     * An array containing the form page returned for the specified form id.
                     */
                    formPage: {
                        type: Array,
                        notify: true
                    },
                    /**
                     * Filter for the uva library api call to select only the form id requested.
                     */
                    _formFilter: {
                        type: Object,
                        computed: '_filter(formId)'
                    },
                    /**
                     * The form elements.
                     */
                    _elements: {
                        type: Array,
                        notify: true,
                        reflectToAttribute: true,
                        computed: '_parsePageForm(formPage,userInfo)'
                    },
                    /**
                     * Authenticated form indicator.
                     */
                    _authenticated: {
                        type: Boolean,
                        computed: '_isFormAuthenticated(_elements)'
                    },
                    /**
                     * Form confirmation page path.
                     */
                    _confirmationPagePath: {
                        type: String,
                        computed: '_getConfirmationPagePath(_elements)'
                    },
                    /**
                     * list of field ids containing errors, each with an appropriate message.
                     */
                    _errors: {
                      type: Array,
                      value: function(){return []},
                      notify: true
                    },
                    /**
                     * Indicator there are fields with missing or invalid data.
                     */
                    _invalidValues: {
                      type: Boolean,
                      computed: '_errorsFound(_errors)',
                      notify: true
                    },
                    /**
                     * Appropriate aria-live attribute value in the event of a form submission error.
                     */
                    _alertLevel: {
                      type: String,
                      computed: '_ariaLiveAlert(_errors)'
                    },
                    _counter: {
                      type: Number,
                      value:0,
                      notify: true
                    },
                    _firebaseProblem: {
                      type: Boolean,
                      value: false,
                      notify: true
                    },
                    _visible: {
                        type: Boolean,
                        computed: '_readyToDisplayForm(_authenticated,userInfo)',
                        notify: true
                    },
                    _online: {
                      type: Boolean,
                      value: true
                    },
                    _networkConnectionMsg: {
                      type: String,
                      value: ""
                    },
                    _headerHeight: {
                      type:String,
                      value:"0"
                    },
                    /**
                     * delay in milliseconds before setting focus for session content after add or remove
                     */
                    _buttonClickValidationTime: {
                      type: Number,
                      value: 300
                    }
                });
            }

            ready() {
              // @TODO Revisit the idea of checking offline for forms once IE support is ended.
//              window.addEventListener('offline',this._checkOnline.bind(this));
//              window.addEventListener('online',this._checkOnline.bind(this));
//              this._checkOnline();
              super.ready();
            }

            _offlineMessage(online,msg) {
              return (!online) ? msg : "";
            }

            _checkOnline() {
              this._online = navigator.onLine;
              if (this._online) {
                fetch("https://api.library.virginia.edu/online.json")
                .then((response) => {
                  this._networkConnectionMsg = "";
                })
                .catch((err) => {
                  console.log("error");
                  console.log(err.name);
                  console.log(err.message);
                  this._online = false;
                  this._networkConnectionMsg = "Please connect to a different wireless network to submit.";
                });
              } else {
                this._online = false;
                this._networkConnectionMsg = "Please connect to internet to submit.";
              }
            }

            _readyToDisplayForm(_authenticated,userInfo) {
              // If the form is NetBadge protected make sure the user has
              // authenticated before displaying the form
              if (_authenticated) {
                if (userInfo && userInfo.computing_id != '') {
                  return true;
                } else {
                  return false;
                }
              } else {
                return true;
              }
            }

            _errorString(count) {
              return (count == 1) ? 'error' : 'errors';
            }

            /**
             * Handle click event for getting customer between an error link and the corresponding input field.
             */
            _handleAnchor(e) {
              e.preventDefault();
              let target = e.currentTarget.getAttribute('href');
              this.shadowRoot.querySelector(target).scrollIntoView();
              // Adjust the scroll position for the header height, and we want to show the previous element (should be a label or heading)
              window.scroll(0,window.scrollY-parseInt(this._headerHeight)-parseInt(this.shadowRoot.querySelector(target).offsetHeight)-5);
              this.shadowRoot.querySelector(target).focus();
            }

            /**
             * Indicator that errors were discovered when client side validation performed.
             * @return Boolean
             */
            _errorsFound(_errors) {
              return (_errors.length > 0) ? true : false;
            }

            /**
             * If errors exist then the aria-live attribute for the error content should be set to assertive.
             * @return String
             */
            _ariaLiveAlert(_errors) {
              return (_errors.length > 0) ? 'assertive' : '';
            }

            /**
             * Validate that any required field is not empty.
             */
            _validateRequired(key,fldObj) {
              fldObj.valid = true;
              if (fldObj.type == 'text' || fldObj.type == 'email' || fldObj.type == 'tel' || fldObj.type == 'textarea' || fldObj.type == 'select' ||
                  fldObj.type == 'radios' || fldObj.type == 'checkbox' || fldObj.type == 'checkboxes') {
                fldObj.syntax_issue = false;
                if (!this._showField(fldObj)) {
                  fldObj.valid = true;
                } else {
                  if (fldObj.required_error != "") {
                    fldObj.valid = false;
                    this.push('_errors',{"id": key, text: 'The '+fldObj.title+' field is required - '+fldObj.required_error });
                  } else {
                    fldObj.valid = true;
                  }
                }
              } else if (fldObj.type == 'container') {
                // @TODO This added back to address the SIS component. We should define validation "properties/method abstraction" set by each input component.
                if (fldObj.validated != null) {
                  if (fldObj.validated) {
                    fldObj.valid = true;
                  } else {
                    fldObj.valid = false;
                    this.push('_errors',{"id": key, text: 'The '+fldObj.title+' field is empty - this is required and must be filled in.' });
                  }
                } else {
                  // Check to see if the field is visible before indicating an empty required field is invalid.
                  if (!this._showField(fldObj)) {
                    fldObj.valid = true;
                  } else {
                    fldObj.valid = false;
                    this.push('_errors',{"id": key, text: 'The '+fldObj.title+' field is empty - this is required and must be filled in.' });
                  }
                }
              } else if (fldObj.type == 'webform_custom_composite' && (fldObj.element && fldObj.element.media_clip_time)) {
                // do nothing as checking required is handled within the component at the same time as syntax validation.
              } else if (fldObj.type == 'datetime') {
                // do nothing as checking required is handled within the component at the same time as syntax validation.
              } else if (fldObj.type == 'datelist') { // single or repeatable session containing multiple date/times
                // do nothing as checking required is handled within the component at the same time as syntax validation.
              } else {
                console.log(fldObj.type+' not being validated!!!');
              }
            }

            /**
             * Test that an email input type field contains a string that represents a validly formatted email address.
             */
            _validateEmail(key,fldObj) {
              var emailRegExp = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
              var error_msg = ' does not look like an email address, please check the value you entered.';
              // Check to see if the field is visible before indicating an empty required field is invalid.
              if (!this._showField(fldObj)) {
                fldObj.valid = true;
                fldObj.syntax_issue = false;
              } else {
                if (!emailRegExp.test(fldObj.value)) {
                  fldObj.syntax_issue = true;
                  // when testing for a syntax error append the error to an existing error if appropriate; otherwise add it to the error list.
                  if (this._errors[key]) {
                    this._errors[key].text += ' And it'+error_msg;
                  } else {
                    fldObj.valid = false;
                    this.push('_errors',{"id": key, text: 'The '+fldObj.title+' field input'+error_msg });
                  }
                } else {
                  fldObj.valid = true;
                  fldObj.syntax_issue = false;
                }
              }
            }

            _validateFile(key,fldObj) {
              if (!this._showField(fldObj)) {
                fldObj.valid = true;
                fldObj.syntax_issue = false;
              } else {
                // if not empty
                // Validation is performed within file component;
                // returns any syntax_errors message.
                var errMsg = (fldObj.required_error != "" || fldObj.syntax_error != "") ? 'The '+fldObj.title : '';
                if (errMsg != "") {
                  fldObj.valid = false;
                  errMsg += (fldObj.required_error != "") ? ' contains required content: ' : ' contains errors: ';
                  errMsg += fldObj.required_error;
                  if (fldObj.syntax_error != "") {
                    fldObj.syntax_issue = true;
                    errMsg += ' '+fldObj.syntax_error;
                  }
                  this.push('_errors',{"id": key, text: errMsg });
                }
              }
            }

            /**
             * Test that a telephone number input type field contains a string that represents a validly formatted telephone number.
             */
            _validatePhone(key,fldObj) {
              var phoneRegExp = /^(?:(?:\+?1\s*(?:[.-]\s*)?)?(?:\(\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\s*\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\s*(?:[.-]\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\s*(?:[.-]\s*)?([0-9]{4})(?:\s*(?:#|x\.?|ext\.?|extension)\s*(\d+))?$/;
              var error_msg = ' does not look like a phone number, please check the value you entered.';
              if (!this._showField(fldObj)) {
                fldObj.valid = true;
                fldObj.syntax_issue = false;
              } else {
                if (!phoneRegExp.test(fldObj.value)) {
                  fldObj.syntax_issue = true;
                  // when testing for a syntax error append the error to an existing error if appropriate; otherwise add it to the error list.
                  if (this._errors[key]) {
                    this._errors[key].text += ' And it'+error_msg;
                  } else {
                    fldObj.valid = false;
                    this.push('_errors',{"id": key, text: 'The '+fldObj.title+' field input'+error_msg });
                  }
                } else {
                  fldObj.valid = true;
                  fldObj.syntax_issue = false;
                }
              }
            }

            /**
             * Validate a date and time field for required and syntax problems.
             */
            _validateDateTimeField(key,fldObj) {
              if (!this._showField(fldObj)) {
                fldObj.valid = true;
                fldObj.syntax_issue = false;
              } else {
                // Validation is performed within each date/time complex component;
                // each component has an attribute that returns any required_error message
                // and/or syntax_errors message.
                var errMsg = (fldObj.required_error != "" || fldObj.syntax_error != "") ? 'The '+fldObj.title : '';
                if (errMsg != "") {
                  errMsg += (fldObj.required_error != "") ? ' contains required content: ' : ' contains errors: ';
                  errMsg += fldObj.required_error;
                  if (fldObj.syntax_error != "") {
                    fldObj.syntax_issue = true;
                    errMsg += ' '+fldObj.syntax_error;
                  }
                  this.push('_errors',{"id": key, text: errMsg });
                }
              }
            }

            /**
             * Validate a date and time field for required and syntax problems.
             */
            _validateMediaClipField(key,fldObj) {
              console.log('media clip validation');
              if (!this._showField(fldObj)) {
                fldObj.valid = true;
                fldObj.syntax_issue = false;
              } else {
                // Validation is performed within each media clip complex component;
                // each component has an attribute that returns any required_error message
                // and/or syntax_errors message.
                var errMsg = (fldObj.required_error != "" || fldObj.syntax_error != "") ? 'The '+fldObj.title : '';
                if (errMsg != "") {
                  errMsg += (fldObj.required_error != "") ? ' contains required content: ' : ' contains errors: ';
                  errMsg += fldObj.required_error;
                  if (fldObj.syntax_error != "") {
                    fldObj.syntax_issue = true;
                    errMsg += ' '+fldObj.syntax_error;
                  }
                  this.push('_errors',{"id": key, text: errMsg });
                }
              }
            }

            /**
             * Validate input fields found in a form section.
             */
            _validateSection(fldIndex) {
              for (var key in this._elements[fldIndex]) {
                if (key.match(/^fld_/)) {
                  if (this._elements[fldIndex][key]._required || this._elements[fldIndex][key].required) {
                    this._validateRequired(key,this._elements[fldIndex][key]);
                  }
                  if ((this._elements[fldIndex][key].type == 'email') && this._elements[fldIndex][key].value != '') {
                    this._validateEmail(key,this._elements[fldIndex][key]);
                  }
                  if ((this._elements[fldIndex][key].type == 'tel') && this._elements[fldIndex][key].value != '') {
                    this._validatePhone(key,this._elements[fldIndex][key]);
                  }
                  if (((this._elements[fldIndex][key].type == 'datetime') || (this._elements[fldIndex][key].type == 'datelist')) && this._elements[fldIndex][key].value != '') {
                    this._validateDateTimeField(key,this._elements[fldIndex][key]);
                  }
                  if ((this._elements[fldIndex][key].type == 'webform_custom_composite') && (this._elements[fldIndex][key].element && this._elements[fldIndex][key].element.media_clip_time)) {
                    this._validateMediaClipField(key,this._elements[fldIndex][key]);
                  }
                  if ((this._elements[fldIndex][key].type == 'file') && this._elements[fldIndex][key].valid) {
                    this._validateFile(key,this._elements[fldIndex][key]);
                  }
                }
              }
            }

            /**
             * Actions to be performed when a button is clicked.
             */
            _buttonClicked(e) {
              if (e.detail.name == 'Submit') {
                this._errors = [];
                this._errorList = "";
                // give components that need to perform validation a moment to do this.
                this._counter = this._counter+1;
                setTimeout(function() {
                  // let various components perform validation before continuing on
                }, this._buttonClickValidationTime);
                // Loop through form fields to make sure required items have values
                for (var i=0; i<this._elements.length; i++) {
                  // only validate an input field if it is showing on the screen...
                  if (this._showField(this._elements[i])) {
                    let field = this._elements[i].webform_key;
                    if (field.match(/^sect_/)) {
                      this._validateSection(i);
                    } else if (field.match(/^fld_/)) {
                      if (this._elements[i]._required || this._elements[i].required) {
                        this._validateRequired(field,this._elements[i]);
                      }
                      if ((this._elements[i].type == 'email') && this._elements[i].valid) {
                        this._validateEmail(field,this._elements[i]);
                      }
                      if ((this._elements[i].type == 'tel') && this._elements[i].valid) {
                        this._validatePhone(field,this._elements[i]);
                      }
                      if (((this._elements[i].type == 'datetime') || (this._elements[i].type == 'datelist')) && this._elements[i].valid) {
                        this._validateDateTimeField(field,this._elements[i]);
                      }
                      if ((this._elements[i].type == 'webform_custom_composite') && (this._elements[i].element && this._elements[i].element.media_clip_time)) {
                        console.log('media clip'); // ***** ADD FOR DEBUGGING
                        this._validateMediaClipField(field,this._elements[i]);
                      }
                      if ((this._elements[i].type == 'file') && this._elements[i].valid) {
                        this._validateFile(field,this._elements[i]);
                      }
                    }
                  }
                }
                // need to refresh errors to make sure they get reflected
                this._errors = JSON.parse(JSON.stringify(this._errors));

                // if invalid input then reset the array
                if (this._errors.length > 0) {
                  this._elements = JSON.parse(JSON.stringify(this._elements));
                  // Scroll the form-builder into view since the error message shows up at the top
                  this.scrollIntoView();
                  // Adjust the scroll position for the header height, and we want to show the previous element (should be a label or heading)
                  if (this.previousElementSibling) {
                    window.scroll(0,window.scrollY-parseInt(this._headerHeight)-parseInt(this.previousElementSibling.offsetHeight)-5);
                  } else {
                    window.scroll(0,window.scrollY-parseInt(this._headerHeight)-5);
                  }
                  this.shadowRoot.querySelector('#errorList').focus();
                  this.shadowRoot.querySelector('#btn_submit').submitted = false;
                  this.shadowRoot.querySelector('#btn_submit').disabled = false;
                } else {
                  // otherwise save the results
                  // before saving check to see if the form contains a honeypot or not and make sure if it does that it's empty
                  if (!this._formHasHoneypot(this._elements) || (this._formHasHoneypot(this._elements) && this._honeypotValue(this._elements) == "")) {
                    this.$.user.saveRequest(this._elements)
                      .then(results => {
                        if (results.requestPathWrite) {
                          // redirect to the confirmation page
                          if ((this._confirmationPagePath.indexOf('http://') === 0) || (this._confirmationPagePath.indexOf('https://') === 0)) {
                            window.location.replace(this._confirmationPagePath);
                          } else {
                            let slash = (this._confirmationPagePath.indexOf('/') === 0) ? '' : '/';
                            window.location.replace("https://library.virginia.edu"+slash+this._confirmationPagePath);
                          }
                        } else {
                          console.log(results.message); // This may not be a useful message to display to patrons but we can always view Firebase logs to see technical errors.
                          this._firebaseProblem = true;
                          this._errors = JSON.parse(JSON.stringify(this._errors));
                          this.push('_errors',{"id": 'btn_submit', text: 'Unable to submit your request at this time. Please wait a minute and try again.' });
                          // Scroll the form-builder into view since the error message shows up at the top
                          this.scrollIntoView();
                          // Adjust the scroll position for the header height, and we want to show the previous element (should be a label or heading)
                          if (this.previousElementSibling) {
                            window.scroll(0,window.scrollY-parseInt(this._headerHeight)-parseInt(this.previousElementSibling.offsetHeight)-5);
                          } else {
                            window.scroll(0,window.scrollY-parseInt(this._headerHeight)-5);
                          }
                          this.shadowRoot.querySelector('#errorList').focus();
                          this.shadowRoot.querySelector('#btn_submit').submitted = false;
                          this.shadowRoot.querySelector('#btn_submit').disabled = false;
                        }
                      })
                      .catch(error => {
                        console.log(error);
                      });
                  }
                }
//                this._counter = this._counter+1;
                console.log(this._elements);
              }
            }

            /**
             * Filter API web forms to get the one needed.
             * @return Object
             */
            _filter(id) {
                return {
                    'target_id': id
                };
            }

            /**
             * Check authenticated field value to determine if form requires NetBadge.
             * @return Boolean
             */
            _isFormAuthenticated(els) {
                let auth = _.find(els, {
                    title: 'authenticated'
                });
                return (auth && auth.value && auth.value == "yes") ? true : false;
            }

            /**
             * Check if captcha field exists to determine if form has honeypot.
             * @return Boolean
             */
            _formHasHoneypot(els) {
                let captcha = _.find(els, {
                    type: 'captcha'
                });
                return (captcha) ? true : false;
            }

            /**
             * return the value of the honeypot captcha input field
             */
            _honeypotValue(els) {
              let captcha = _.find(els, {
                type: 'captcha'
              });
              return (captcha && captcha.value) ? captcha.value : '';
            }

            /**
             * Get the path for the confirmation page.
             * @return String
             */
            _getConfirmationPagePath(els) {
                let path = _.find(els, {
                    title: 'confirmation page path'
                });
                return (path && path.value)? path.value: null;
            }

            /**
             * Set the value of a field depending on its type.
             */
            _preprocessField(fldObj,user) {
              let setVal;
              fldObj.valid = true;
              // for text field make sure the type matches up with the HTML input expected
              if (fldObj.type && fldObj.type == 'textfield') {
                fldObj.type = 'text';
              }
              if (fldObj.type && fldObj.type == 'managed_file') {
                fldObj.type = 'file';
              }
              if (fldObj.type && fldObj.type == 'checkboxes') {
                fldObj.value = {};  // need to override value specified by Drupal JSON output
              }
              // if the field should be auto-filled then do so...
              if (fldObj.data_auto_fill) {
                if (fldObj.data_source == 'userInfo') {
                  // if the field is a select, radio or checkbox then we need to set the value differently;
                  // otherwise the field's value is set to the user property value.
                  switch (fldObj.type) {
                    case 'select':
                      // look for an option that contains some portion of the value it should be
                      // @TODO this may require review depending on values that ITS has for patrons in new LDAP
                      setVal = new RegExp(user[fldObj.data_source_field].toLowerCase());
                      for (let opt in fldObj.options) {
                        let setVal2 = new RegExp(fldObj.options[opt].toLowerCase());
                        if (setVal.test(fldObj.options[opt].toLowerCase()) || setVal2.test(user[fldObj.data_source_field].toLowerCase())) {
                          fldObj.default_value = fldObj.value = fldObj.options[opt];
                        }
                      }
                      // if after this there is no value/choose one/select one and there is an Other... option in select
                      // then set value to Other...
                      if (((fldObj.value == '') || (fldObj.value == 'Choose one') || (fldObj.value == 'Select one')) && _.has(fldObj.options, 'Other...')) {
                        fldObj.default_value = fldObj.value = 'Other...';
                      }
                      break;
                    case 'radios':
                      // look for an option that contains some portion of the value it should be
                      // @TODO this may require review depending on values that ITS has for patrons in new LDAP
                      setVal = new RegExp(user[fldObj.data_source_field].toLowerCase());
                      for (let opt in fldObj.options) {
                        let setVal2 = new RegExp(fldObj.options[opt].toLowerCase());
                        if (setVal.test(fldObj.options[opt].toLowerCase()) || setVal2.test(user[fldObj.data_source_field].toLowerCase())) {
                          fldObj.default_value = fldObj.options[opt];
                          fldObj.value = fldObj.options[opt];
                        }
                      }
                      break;
                    case 'checkbox':
                      fldObj.checked = (user[fldObj.data_source_field]) ? true : false;
                      break;
                    case 'button':
                      break;
                    case 'text':
                    case 'textarea':
                    case 'tel':
                    case 'email':
                    case 'hidden':
                      fldObj.value = user[fldObj.data_source_field];
                  }
                }
              }
            }

            /**
             * Returns web form definition for the form page object.
             * @return Array
             */
            _parsePageForm(frmPg,userInfo) {
                var fields = Array();
                if (frmPg) {
                    var form = JSON.parse(frmPg[0].webform);
                    for (var key in form) {
                        if (key.match(/^sect_/)) {
                          for (var skey in form[key]) {
                            if (skey.match(/^fld_/)) {
                              this._preprocessField(form[key][skey],userInfo);
                            }
                          }
                        }
                        if (key.match(/^sect_|fld_|mkup_|btn_|authenticated|confirmation/)) {
                            fields.push(form[key]);
                            this._preprocessField(form[key],userInfo);
                        }
                    }
                }
                console.log(fields);
                return fields;
            }

        }

        window.customElements.define(UvalibFormBuilder.is, UvalibFormBuilder);
    </script>
</dom-module>
